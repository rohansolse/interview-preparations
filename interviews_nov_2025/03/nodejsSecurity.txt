Here’s a practical checklist for securing a Node.js (Express) application. I’ll keep it hands-on with code where it helps.

---

## 1. Use HTTPS and secure reverse proxy

* Terminate TLS at Nginx/Load Balancer (or directly in Node for small setups).
* Always redirect HTTP → HTTPS.
* Set **HSTS** header to force browsers to use HTTPS (Helmet does this, see below). ([Node.js][1])

---

## 2. Add security headers with Helmet

Install and plug in **helmet** in Express:

```bash
npm install helmet
```

```js
// app.js
const express = require('express');
const helmet = require('helmet');

const app = express();

// Basic Helmet setup
app.use(helmet());

// Example: custom CSP
app.use(
  helmet.contentSecurityPolicy({
    useDefaults: true,
    directives: {
      "default-src": ["'self'"],
      "img-src": ["'self'", "data:"],
      "script-src": ["'self'"],
    },
  })
);
```

Helmet sets headers like `Content-Security-Policy`, `X-Frame-Options`, `Strict-Transport-Security`, `X-Content-Type-Options`, etc., which mitigate XSS, clickjacking, MIME sniffing, etc. ([Helmet][2])

---

## 3. Input validation & sanitization

Never trust request data: query, params, body, headers, cookies.

Use libraries like **Joi**, **zod**, or **express-validator** and sanitize strings (remove script tags, etc.). ([Node.js][1])

Example with Joi:

```bash
npm install joi
```

```js
const Joi = require('joi');

const userSchema = Joi.object({
  name: Joi.string().min(3).max(50).required(),
  email: Joi.string().email().required(),
});

app.post('/users', async (req, res) => {
  const { error, value } = userSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  // safe to use value
});
```

---

## 4. Prevent SQL / NoSQL Injection

* **Always** use parameterized queries / query builders / ORM (Sequelize, TypeORM, Mongoose).
* Never build queries with string concatenation.

Example with PostgreSQL (pg):

```js
// BAD ❌
await pool.query(`SELECT * FROM users WHERE email = '${email}'`);

// GOOD ✅
await pool.query('SELECT * FROM users WHERE email = $1', [email]);
```

With Mongo/Mongoose, avoid using user input directly in operators like `$where`, `$regex` without whitelist/validation. ([OWASP Cheat Sheet Series][3])

---

## 5. Secure authentication & sessions

### If you use JWT:

* Use strong secret / RSA keys, keep them in env vars, **never** commit to git.
* Use short expiration (`exp`), rotate tokens, and refresh tokens carefully.
* Validate signature and claims on every request. ([Node.js][1])

Example:

```js
const jwt = require('jsonwebtoken');

function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Missing token' });

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}
```

### If you use sessions:

* Use **secure**, **httpOnly** cookies, `sameSite=strict` or `lax`.
* Store sessions server-side (Redis, DB) — not sensitive data in the cookie.

---

## 6. Strong authorization (access control)

* Do **not** rely only on front-end checks.
* Implement role/permission checks in your Node routes/services.
* Never use ID from client directly without checking ownership (avoid **Insecure Direct Object References**).

Example:

```js
app.get('/orders/:id', authMiddleware, async (req, res) => {
  const order = await Order.findByPk(req.params.id);
  if (!order || order.userId !== req.user.id) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  res.json(order);
});
```

OWASP highlights broken access control as one of the most critical issues. ([Node.js][1])

---

## 7. Protect against XSS

For APIs:

* Return JSON only, no HTML.
* On frontend, **never** use `innerHTML` with unsanitized content.

For server-side rendering or template engines:

* Use templating that auto-escapes (EJS, Pug, Handlebars).
* Configure **CSP** via Helmet to restrict scripts. ([Helmet][2])

---

## 8. CSRF protection (for cookie/session-based apps)

If your app uses browser cookies for auth (not pure token-in-header SPA), enable **CSRF tokens**:

```bash
npm install csurf
```

```js
const csurf = require('csurf');
app.use(csurf({ cookie: true }));
```

Combine with `SameSite` cookies and HTTPS. ([OWASP Cheat Sheet Series][3])

---

## 9. Secure file uploads & paths

* Limit allowed MIME types and file sizes.
* Store files outside web root or in object storage (S3, etc).
* Create random filenames; never trust user-supplied paths (avoid path traversal).
* Use libraries like `multer` and validate everything.

---

## 10. Rate limiting & brute-force protection

* Add rate limiting per IP / per user on:

  * login,
  * password reset,
  * any expensive endpoint.

Example with `express-rate-limit`:

```bash
npm install express-rate-limit
```

```js
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 5,
  message: { error: 'Too many login attempts, try again later.' }
});

app.post('/login', loginLimiter, loginController);
```

This mitigates brute-force and DDoS at application level. ([OWASP Cheat Sheet Series][3])

---

## 11. Secrets & configuration management

* Use environment variables or a secret manager (AWS Secrets Manager, Vault, etc.).
* Never commit `.env` to git.
* Use different configs per environment (dev / test / prod).
* Restrict who can read production env vars/keys. ([Node.js][1])

---

## 12. Dependency security

* Keep Node and npm up to date.
* Regularly run:

```bash
npm audit
npm audit fix
```

or use **Snyk**, **Dependabot**, etc. ([OWASP Cheat Sheet Series][3])

* Remove unused packages.
* Avoid unmaintained or suspicious libraries.


## 13. Logging, monitoring, and error handling

* Log security-relevant events (logins, failures, permission errors) to a central system.
* Don’t log sensitive data (passwords, full card numbers, OTP).
* For errors, send generic messages to the client and detailed logs to server only.

Example:

```js
app.use((err, req, res, next) => {
  console.error(err); // or Winston, Pino, etc.
  res.status(500).json({ error: 'Something went wrong' });
});
```
